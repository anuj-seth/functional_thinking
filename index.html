<!doctype html>
<html lang="en">

	  <head>
		    <meta charset="utf-8">

		    <title>Clojure - made with secret alien technology</title>

		    <meta name="description" content="Slides for the functional thinking with clojure training">
		    <meta name="author" content="Anuj Seth">

		    <meta name="apple-mobile-web-app-capable" content="yes">
		    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">

		    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">

		    <link rel="stylesheet" href="reveal.js/css/reveal.css">
		    <link rel="stylesheet" href="reveal.js/css/theme/black.css" id="theme">
		    <link rel="stylesheet" href="custom.css">

		    <!-- Code syntax highlighting -->
		    <link rel="stylesheet" href="reveal.js/lib/css/zenburn.css">

		    <!-- Printing and PDF exports -->
		    <script>
			   var link = document.createElement( 'link' );
			   link.rel = 'stylesheet';
			   link.type = 'text/css';
			   link.href = window.location.search.match( /print-pdf/gi ) ? 'reveal.js/css/print/pdf.css' : 'reveal.js/css/print/paper.css';
			   document.getElementsByTagName( 'head' )[0].appendChild( link );
		    </script>

		    <!--[if lt IE 9]>
		        <script src="lib/js/html5shiv.js"></script>
		    <![endif]-->
	  </head>

	  <body>

		    <div class="reveal">

			      <!-- Any section element inside of this container is displayed as a slide -->
			      <div class="slides">
				        <section>
					          <h1>Clojure</h1>
					          <p>
                        <img src="resources/images/alien_technology.png">
					              <br><small>Trainer <a>Anuj Seth</a> </small></br>
					          </p>
				        </section>

                <section data-markdown>
                    <script type="text/template">
                     <h2>What is functional programming ?</h2>
                     <p>Let's look at some features of functional languages</p>
                     <p class="fragment">Functions as first class objects</p>
                     <p span class="fragment">Composition of functions</p>
                     <p span class="fragment">Purity<p>
	                   <p span class="fragment">Immutability</p>
	                   <p span class="fragment">Laziness</p>
                    </script>
	              </section>

                <section>
                    <h2>What is Clojure ?</h2>
                    <p>A dialect of Lisp that runs on the JVM, CLR and also targets JavaScript</p>
                    <p>Created by Rich Hickey<p>
				            <p>Functional programming language (?)</p>
				            <p>Big emphasis on concurrency</p>
				        </section>


				        <section>
                    <h2>The REPL</h2>
                    <p>Read, Eval, Print, Loop</p>
                    <p>Interactive shell<p>
				            <p>Use it for exploratory programming</p>
                    <p>Provides a quick feedback cycle</p>
				            <p>Connect to your application running in production</p>
				            <p>Essential part of the lisp experience</p>
				        </section>

                <section data-markdown>
                    ```clj
                    "i am a string"
                    ;=> "i am a string"

                    (= 1 2)
                    ;=> false

                    (+ 1 2 3 4)
                    ;=> 10

                    (* 1 2 3 4)
                    ;=> 24
                    ```
                </section>

                <section data-markdown>
                    ```clj
                    (first [1 2 3 4])
                    ;=> 1

                    (map inc [1 2 3])
                    ;=> (2 3 4)

                    (remove zero? [1 0 2 0 3 0 4 0 5 0])
                    ;=> (1 2 3 4 5)
                    ```
                </section>

				        <section>
                    <h2>Clojure Syntax</h2>
                    <p>Clojure has a uniform structure, with essentially 2 forms</p>
                    <ul>
                        <li>Literal data structures (vectors, maps, strings)</li>
                        <li>Operations</li>
                    </ul>
				        </section>

                <section data-markdown>
                    ```clj
                    ; this is what data looks like
                    1
                    "a string"
                    ["a" "vector" "of" "things"]

                    ; operations look like this
                    ; (operator op1 op2 ... opN) 
                    ; also called prefix notation
                    (+ 1 2 3 4)

                    ; the operands could be simple values like above,
                    ; or nested forms like below
                    (+ (* 2 3) 1)
                    ```
                </section>

                <section data-markdown>
                    ```clj
                    ; note that all functions/operators are called the same way,
                    ; inbuilt or user defined

                    ; this is not a valid clojure form
                    (+

                    ; and if you have not guessed by now,
                    ; comments start with a semi-colon
                    ```
                </section>


				        <section>
                    <h2>Clojure Syntax</h2>
                    <h4>Control Flow</h4>
                    <p>Let's look at the three basic control flow operators</p>
                    <p>if, do and when</p>
				        </section>
                
                <section data-markdown>
                    ```clj
                    ; this is what an if condition looks like
                    ; (if boolean-form
                    ;     then-form
                    ;     optional-else-form)
                    (if true
                      "hello"
                      "bye")
                    ;=> "hello"

                    ; if you omit the else form and your boolean 
                    ; expression returns false then what will happen ?
                    (if false
                      "hello")
                    ```
                </section>

                <section data-markdown>
                    ```clj
                    ; all lisp/clojure forms return a value when evaluated.
                    ; in some cases that value may be nil.
                    ; and that's why Alan Perlis said .....
                    ```
                </section>

                <section>
	                  <blockquote>
	                      Lisp programmers know the value of everything and the cost of nothing.<br>—Alan Perlis
	                  </blockquote>
	              </section>

                <section data-markdown>
                    ```clj
                    ; 'if' relies on the position of operands to 
                    ; associate code with the then branch and
                    ; the optional else branch.
                    ; hence the first form is the then branch and second form 
                    ; is the else branch.
                    ; type the following on your repl
                    (if false
                      "hello" 
                      (println "bye")
                      "good bye")

                    ; this brings us to the 'do' operator
                    ```
                </section>

                <section data-markdown>
                    ```clj
                    ; the do operator allows you to wrap up multiple forms
                    ; and run each of them
                    (if false
                      (do 
                        (println "hello")
                        (println "world"))
                      (do 
                        (println "good bye")
                        (println "world")))

                    ; do returns the value of the last expression evaluated
                    (do
                      "clojure"
                      "is fun") 
                    ```
                </section>

                <section data-markdown>
                    ```clj
                    ; the 'when' operator is like a combination of if and do,
                    ; without the else branch.
                    ; when allows you to evaluate a number of forms when some 
                    ; condition is true and always return nil when it is false
                    (when true
                      (println (+ 1 2))
                      (+ 1 2))
                    ```
                </section>

				        <section>
                    <h2>Clojure Syntax</h2>
                    <h4>true, false, nil and boolean expressions</h4>
                    <p>Clojure has boolean true and false</p>
                    <p>and nil is used to indicate no value.</p>
                    <p>Only false and nil are considered logically false</p>
                    <p>Everything else is logical truth</p>
				        </section>

                <section>
                    <pre><code data-sample='code/files/boolean_test.clj'>
                    </code></pre>
                </section>

                <section data-markdown>
                    ```clj
                    ; clojure has the boolean operators 'or' and 'and'

                    ; or returns true if it encounters a form that evaluates 
                    ; to true else it returns the value of last expression
                    (or (= 1 0) (= "yes" "no"))
                    ;=> false

                    ; and returns the first false value or the value of
                    ; the last expression
                    (and 1 2 3 [])
                    ;=> []
                    ```
                </section>

                <section>
                    <h4>What's with the parentheses and weird syntax ?</h4>
                    <p>No precedence rules for arithmetic or bitwise operators</p>
                    <p>Uniform function call syntax</p>
                    <p>Textual clojure is very close to internal representation of that code</p>
                    <p>Think code as data or programs that write programs</p>
				        </section>

                <section data-markdown>
                    ```java
                    // notice how Clojure syntax is different from
                    // languages like java where you have a mixture of
                    // infix operators, dot operators and parentheses
                    int number = 5;
                    int factorial = number;
                    for(int i = (number - 1); i > 1; i--) {
                        factorial = factorial * i;
                    }
                    System.out.println("Factorial of a number is " + factorial);
                    // why does this matter ?
                    ```
                    ```clj
                    (def number 5)
                    (apply * (range 1 (inc number)))
                    ```
                </section>

                <section>
                    <img src="resources/images/lisp_cycles.png"> 
                </section>


                <section>
                    <h2>Clojure Data Types</h2>
                    <p>Two categories</p>
                    <ul>
                        <li>Scalars</li>
                        <li>Collections</li>
                    </ul>
                    
				        </section>

                <section data-markdown>
                    Scalars
                    Numbers
                    ---------
                    ```clj
                    ; integer, float and rational
                    42
                    42.0
                    85/3

                    ; rationals will be simplified, if possible
                    100/4
                    ;=> 25

                    ; and you can even do rational arithmetic
                    (+ 85/3 1/3)
                    ;=> 86/3
                    ```
                </section>

                <section data-markdown>
                    Scalars
                    Strings and Characters
                    ---------
                    ```clj
                    ; strings can only be double quoted
                    "Rich Hickey is the creator of clojure"
                    ;=> "Rich Hickey is the creator of clojure"

                    ; characters are written with a literal syntax
                    \a
                    ;=> \a

                    \A
                    ;=> \A
                    ```
                </section>

                <section data-markdown>
                    Scalars
                    Symbols
                    ---------
                    ```clj
                    ; symbols represent other values
                    ; they are also called vars
                    ; and are the closest to variables in other languages
                    (def small-pi 22/7)
                    ;=> #'user/small-pi

                    small-pi
                    ;=> 22/7

                    ; used to refer to locals, function parameters,
                    ; and globals
                    ```
                </section>

                <section data-markdown>
                    Scalars
                    Keywords
                    ---------
                    ```clj
                    ; self evaluating types prefixed by one or more colons
                    :this-is-a-keyword
                    ;=> :this-is-a-keyword

                    ; this is a namespace qualified keyword
                    ::this-is-a-keyword
                    ;=> :user/this-is-a-keyword

                    ; they are used as keys in maps
                    (def population {:girls 2700, :boys 9})

                    ; also used as enumerations - :small , :medium, :large
                    ```
                </section>


                <section data-markdown>
                    Collections
                    Lists
                    -----
                    ```clj
                    ; lists are the classic collection types in clojure
                    ; or any lisp.
                    ; this is a list. try typing this on the REPL
                    (1 2 3 "Hello" :world)

                    ; when lists are evaluated, the first item is resolved to a 
                    ; function, macro or a special form like do,let, etc

                    ; you can quote a list to prevent evaluation
                    '(1 2 3 "Hello" :world)

                    ```
                </section>

                <section data-markdown>
                    Side Note
                    quote
                    -----
                    ```clj
                    ; the quote special operator prevents it's arguments from 
                    ; being evaluated at all.
                    (def age 9)
                    age
                    ;=> 9

                    (quote age)
                    ;=> age

                    ; ' is a shortform for quote
                    '(1 2 3 boogey)
                    ;=> (1 2 3 boogey)
                    ```
                </section>

                <section data-markdown>
                    Side Note
                    quote
                    -----
                    ```clj
                    ; quote is most commonly used when we want to use a
                    ; literal list as a data collection.
                    ; not so much used in clojure as it was in lisp,
                    ; but still supported

                    ; note that the empty, (), list evaluates to itself,
                    ; no need of quoting 
                    ```
                </section>

                <section data-markdown>
                    Collections
                    Lists
                    -----
                    ```clj
                    ; open the file lists_test.clj and make the test
                    ; cases pass

                    ; note - conj function will return a new list with one
                    ; or more items added to the front

                    ```
                </section>

                <section>
                    <pre><code data-sample='code/files/lists_test.clj#5-9'>
                    </code></pre>
                </section>

                <section data-markdown>
                    Collections
                    Vectors
                    -------
                    ```clj
                    ["This" :is "a vector" 1 2 3]

                    ; make the test cases in vectors_test.clj pass
                    ```
                </section>

                <section data-markdown>
                    Collections
                    cons vs conj
                    -------
                    ```clj
                    ; conj adds element to the front or back of a data structure 
                    ; based on the type
                    (= __ (conj '(1 2 3) 4))

                    (= __ (conj [1 2 3] 4))

                    ; what do you think will happen in case of cons ?
                    (= __ (cons 4 [1 2 3]))

                    (= __ (cons 4 '(1 2 3))
                    ```
                </section>

                <section data-markdown>
                    Collections
                    Maps
                    -------
                    ```clj
                    ; maps store key value pairs,
                    ; similar to dictionaries or hashes
                    {:first-name "Rich"
                    :last-name "Hickey"}

                    ; extracting values
                    (:first-name {:first-name "Rich" :last-name "Hickey"})
                    ;=> "Rich"
                    ({:first-name "Rich" :last-name "Hickey"} :first-name)
                    ;=> "Rich"

                    ; keywords and maps act as functions here
                    ```
                </section>

                <section data-markdown>
                    Collections
                    Maps
                    -------
                    ```clj
                    ; map values can be of any type — strings, numbers, maps,
                    ; vectors, even functions.
                    ; what does the value in below map tell us ?
                    {"+" +}
                    ;=> {"+" #&ltcore$_PLUS_ clojure.core$_PLUS_@1bc94f42&gt}

                    ; can i use a function as a map key ?
                    ; what do you think ? should we try at the repl and see ?
                    ```
                </section>

                <section>
                    <pre><code data-sample="code/files/maps_test.clj#5-12">
                    </code></pre>
                </section>

                <section data-markdown>
                    Collections
                    Maps
                    -------
                    ```clj
                    ; you can also define a default value to return
                    ; if the key is not found in a map
                    ({:a 1 :b 2} :b 0)
                    ;=> 2

                    ({:a 1 :b 2} :c 0)
                    ;=> 0

                    (:c {:a 1 :b 2} 0)
                    ;=> 0

                    (get {:a 1 :b 2} :c 0)
                    ;=> 0
                    ```
                </section>

                <section data-markdown>
                    Collections
                    Sets
                    -------
                    ```clj
                    ; sets store unique values and 
                    ; are written using curly braces with a leading hash 
                    (hash-set 1 1 2 2)
                    ;=> #{1 2}

                    (= #{1 2} (hash-set 1 1 2 2))
                    ;=> true
                    ```
                </section>

                <section>
                    <pre><code data-sample="code/files/sets_test.clj#5-12">
                    </code></pre>
                </section>

                <section>
                    <h2>Functions</h2>
                    <h4>Defining your own</h4>
                    <p>We said Clojure was a functional programming language</p>
                    <p>It's time we saw how to define our own functions</p>
				        </section>

                <section data-markdown>
                    Functions
                    ---------
                    ```clj
                    ; an anonymous clojure function can be defined 
                    ; using a special form.
                    ; let's define an anonymous function that takes 2 arguments
                    ; and returns a set
                    (fn [a b] 
                      (println "making a set")
                      #{a b})

                    ;=> #object[user$eval3$fn__4 0x1ec9bd38 "user$eval3$fn__4@1ec9bd38"]

                    ; when you type the above code at the repl,
                    ; you see a strange result.
                    ; this is the internal name of the function 
                    ```
                </section>

                <section data-markdown>
                    Functions
                    ---------
                    ```clj
                    ; how can i call an anonymous function ?
                    ; remember we said that clojure forms look like this
                    ; (operator op1 op2 .. opN)

                    ; try calling the above function with arguments - :x and "y"
                    ; replace the operator with the function we wrote
                    ```
                </section>

                <section data-markdown>
                    Functions
                    ---------
                    ```clj
                    ; a shorthand for anonymous functions uses the
                    ; #() form
                    ; we could have defined our function as
                    (#(hash-set %1 %2) 1 2)

                    ; the arguments to the function can be accessed using the
                    ; % positional notation

                    ; a limitation of the shorthand form is 
                    ; that it can only be used to execute one form
                    ```
                </section>

                <section>
                    <pre><code data-sample="code/files/functions_test.clj#4-12">
                    </code></pre>
                </section>



                <section data-markdown>
                    Functions
                    ---------
                    ```clj
                    ; let's find out how we can give our functions names.
                    ; 'def' special form is used to create a named symbol.
                    ; let's wrap our make set function in a def
                    (def make-set 
                      (fn [a b] 
                        (println "making a set")
                        #{a b}))

                    ; and now we can call it
                    (make-set 1 2)
                    ;=> making a set
                    ;=> #{1 2}

                    ; this is better, but can we make it even more easier ?
                    ```
                </section>

                <section data-markdown>
                    Functions
                    ---------
                    ```clj
                    ; the clojure way to define functions is to use the
                    ; defn macro
                    (defn make-set
                      "Takes 2 values and makes a set from them"
                      [a b] 
                      (println "making a set")
                      #{a b})

                    ; let's talk about the different parts of defn

                    ; the doc-string can be extracted using doc 
                    (doc make-set)
                    ;=> -------------------------
                    ;=> user/make-set
                    ;=> ([a b])
                    ;=>  Takes 2 values and makes a set from them
                    ;=> nil
                    ```
                </section>

                <section data-markdown>
                    Functions
                    ---------
                    ```clj
                    ; clojure also supports functions with multiple arities,
                    ; i.e. different argument counts for the same function
                    (defn make-set
                      ([a] #{a})
                      ([a b] #{a b}))

                    ; what happens when you call this function with 1 argument ? 
                    ; 2 arguments ?
                    ```
                </section>

                <section data-markdown>
                    Functions
                    ---------
                    ```clj
                    ; how about variable arity functions ?
                    ; you can use & to collect all arguments
                    ; not already bound to inputs, into a sequence
                    (defn arity2+
                      [a b & more]
                      (println (vector a b more)))

                    ; what happens if I call arity2+ with 1 argument ?
                    ```
                </section>

                <section data-markdown>
                    Functions
                    ---------
                    ```clj
                    ; open the file doubler_test.clj
                    ; and make the tests pass
                    ```
                </section>

                <section>
                    <pre><code data-sample="code/files/doubler_test.clj#4-13">
                    </code></pre>
                </section>

                <section data-markdown>
                    Functions
                    ---------
                    ```clj
                    ; open the file value_nil_test.clj
                    ; and make the tests pass
                    ```
                </section>

                <section>
                    <pre><code data-sample="code/files/value_nil_test.clj#4-15">
                    </code></pre>
                </section>

                <section data-markdown>
                    Functions
                    Locals
                    ---------
                    ```clj
                    ; clojure does not have local variables, it has locals
                    ; that cannot vary.
                    ; the 'let' form creates locals and defines their scope.
                    ; let consists of a vector with bindings followed by
                    ; any number of expressions making up the body
                    (let [r 5
                          pi 3.1415
                          r-squared (* r r)]
                      (println "radius is" r)
                      (* pi r-squared))

                    ```
                </section>

                <section data-markdown>
                    ```clj
                    ; open the file let_test.clj
                    ; and make the test cases pass

                    ```
                </section>

                <section>
                    <pre><code data-sample="code/files/let_test.clj#4-24">
                    </code></pre>
                </section>

                <section data-markdown>
                    Side Note 
                    cond
                    ----------
                    ```clj
                    ; cond takes a set of test/expr pairs and evaluates
                    ; the tests in turn
                    ; if a test returns true then the corresponding expression
                    ; is evaluated and it's value returned
                    (let [grade 85]
                      (cond
                        (>= grade 90) "A"
                        (>= grade 80) "B"
                        (>= grade 70) "C"
                        (>= grade 60) "D"
                        :else "F"))
                    ;=> "B"
                    ```
                </section>

                <section data-markdown>
                    destructuring
                    ---------
                    ```clj
                    ; destructuring lets you bind names to values within
                    ; a collection.
                    ; it can be used in function arguments or let bindings
                    (defn my-first
                      [[first-thing]] ; note that first-thing is inside a vector
                      first-thing)

                    (my-first [:a :b :c])
                    ;=> :a

                    ; the extra elements of the input vector are ignored.
                    ```
                </section>

                <section data-markdown>
                    destructuring
                    ---------
                    ```clj
                    ; if the destructuring form exceeds a vector,
                    ; the extra elements are bound to nil
                    (let [[a b c d] [1 2]]
                      (println c d))
                    ;=> nil nil
                    ```
                </section>

                <section data-markdown>
                    destructuring
                    ---------
                    ```clj
                    ; while destructuring you can name as many elements 
                    ; as you want and also use rest parameters
                    (let [[a b c & d] [1 2 3 4 5]]
                      (println a b c) 
                      (println d))
                    ;=> 1 2 3
                    ;=> (4 5)

                    ; :as binds the whole vector to a symbol
                    (let [[a b c & d :as e] [1 2 3 4 5]]
                      (println a b c) 
                      (println d) 
                      (println e))
                    ;=> 2 3
                    ;=> (4 5)
                    ;=> [1 2 3 4 5]
                    ```
                </section>

                <section data-markdown>
                    destructuring
                    ---------
                    ```clj
                    ; open the file destructuring_test.clj
                    ; and make the test cases pass
                    ```
                </section>

                <section>
                    <pre><code data-sample="code/files/destructuring_test.clj#4-12">
                    </code></pre>
                </section>

                <section data-markdown>
                    destructuring
                    ---------
                    ```clj
                    ; destructuring also works with maps
                    (let [{a :a b :b} {:a 1 :b 2}] 
                      a)

                    ; what happens if my map does not have a key
                    ; that is given in the destructuring ?

                    ; if you are naming a symbol equivalent of your map key
                    ; then you can use this shortcut
                    (let [{:keys [a b] :as in-map} {:a 1 :b 2}]
                      [in-map b])
                    ;=> [{:a 1, :b 2} 2]
                    ```
                </section>

	              <section>
	                  <h3>Recursion and Loops</h3>
	                  <ul>
	                      <li>Recursion is the primary looping construct in languages of the lisp family</li>
	                      <li>Let's take a look at a simple example</li>
	                  </ul>
	              </section>

                <section data-markdown>
                    ```clj
                    ; given an input x this function sums from x to 1
                    (defn sum-down-from
                      [x]
                      (if (zero? x)
                        0
                        (+ x (sum-down-from (dec x)))))

                    (sum-down-from 10)
                    ;=> 55

                    (sum-down-from 100000)
                    ;=> StackOverflowError  

                    ; let's try to understand why we get a stack overflow.
                    ```
                </section>

                <section>
                    <img src="resources/images/functional.png"> 
                </section>

                <section data-markdown>
                    ```clj
                    ; let's try to take baby steps towards a tail
                    ; recursive version.
                    ; we introduce an accumulator to our function.
                    ; this is a common technique to turn your function
                    ; tail recursive
                    (defn sum-down-from-acc
                      [sum x]
                      (if (zero? x)
                        sum
                        (sum-down-from-acc (+ sum x) (dec x))))

                    (sum-down-from-acc 0 10)
                    ;=> 55
                    ```
                </section>

                <section data-markdown>
                    ```clj
                    (sum-down-from-acc 0 10000)
                    ;=> StackOverflowError 
                    
                    ; there is still one step left
                    ; use the recur keyword instead of the function name
                    ; when recursing from the tail position
                    (defn sum-down-from-recur
                      [sum x]
                      (if (zero? x)
                        sum
                        (recur (+ sum x) (dec x))))

                    (sum-down-from-recur 0 100000)
                    ```
                </section>

                <section data-markdown>
                    ```clj
                    ; the loop keyword is another way to recurse in clojure
                    ; loop allows you to recurse to a point inside the function.
                    ; let's modify our sum-down-from function to use loop
                    (defn sum-down-from-loop
                      [initial-x]
                      (loop [sum 0
                             x initial-x]
                        (if (zero? x)
                          sum
                          (recur (+ sum x) (dec x)))))

                    ; upon entering the loop form the locals sum and x are 
                    ; initialized just like in let
                    ; recur loops back to the closest loop or fn
                    ```
                </section>

                <section data-markdown>
                    ```clj
                    ; open the file recursion_test.clj
                    ; and make the test case pass
                    ```
                </section>

                <section>
                    <pre><code data-sample="code/files/recursion_test.clj#4-12">
                    </code></pre>
                </section>

                <section data-markdown>
                    ```clj
                    ; let's take another test
                    ; open the file loop_test.clj
                    ; and make the test case pass
                    ```
                </section>

                <section>
                    <pre><code data-sample="code/files/loop_test.clj#4-12">
                    </code></pre>
                </section>


                <!--section data-markdown>
                     ```clj
                     ; write a function called member? which given a scalar data type, elt,
                     ; and a list, returns true if elt is present in the list, false otherwise

                     (= true (member? 1 [1 2 3]))

                     (= true (member? 3 [1 2 3]))

                     (= false (member? 4 [1 2 3]))

                     (= false (member? 4 '(1 2 3)))

                     (= false (member? 4 '(1 2 3 booga)))
                     ```
                     </section>

                     <section data-markdown>
                     ```clj
                     ; here's what i came up with
                     (defn member?
                     [elt lat]
                     (cond
                     (nil? (seq lat)) false
                     (= elt (first lat)) true
                     :else (recur elt (rest lat))))
                     ```
                     </section-->

                <section>
                    <h2>Tower Of Hanoi</h2>
                    <img src="resources/images/tower_of_hanoi.jpg" width="500" height="500">
                </section>

                <section>
                    <p>$$T_0 = 0$$</p>
                    <p>$$T_n = 2.T_{n-1} + 1$$</p>
                </section>
                <section data-markdown>
                    ```clj
                    ; open the file recursive_hanoi_test.clj
                    ; and make the test cases pass
                    ```
                </section>

                <section>
                    <pre><code data-sample="code/files/recursive_hanoi_test.clj#4-15">
                    </code></pre>
                </section>

                <section data-markdown>
                    ```clj
                    ; this is what i came up with
                    (defn hanoi [n]
                      (if (= 0 n)
                        0
                        (inc (*' 2 (hanoi (dec n))))))
                    ```
                </section>

                <section data-markdown>
                    ```clj
                    ; and a tail recursive version
                    (defn hanoi-acc
                      [acc n]
                      (if (= n 0)
                        acc
                        (recur (inc (*' 2 acc)) (dec n))))
                    ```
                </section>

                <section>
                    <h2>map and reduce</h2>
                    <p>map and reduce are the workhorses of functional programming</p>
                    <p>Hadoop MapReduce owes it's existence to ideas from functional programming</p>
                </section>

                <section data-markdown>
                    ```clj
                    ; map creates a new list by applying a function to
                    ; each member of a collection
                    (map inc [0 1 2 3])
                    ;=> (1 2 3 4)

                    ; make this test pass
                    (= __ (map #(+ % 5) '(1 2 3)))

                    ; write a function, mapset, that works like map
                    ; but returns a set
                    (mapset inc [1 1 2 3 4 4 5])
                    ;=> #{4 6 3 2 5}

                    ; hint: (doc set)
                    ```
                </section>
                <section data-markdown>
                    ```clj
                    ; this is what i came up with
                    (defn mapset 
                      [f s]
                      (set (map f s)))
                    ```
                </section>


                <section data-markdown>
                    ```clj
                    ; reduce reduces a collection to a single value.
                    ; it has 2 variants -
                    ; first variant takes a 2 argument function and
                    ; applies the function to the first 2 items of the collection.
                    ; in the next iteration the function will be called on the
                    ; previous return value and the next item from
                    ; the sequence, and so on..
                    (reduce + [1 2 3 4])
                    ;=> 10

                    ; this is what is happening 
                    ; (+ (+ (+ 1 2) 3) 4)
                    ```
                </section>

                <section data-markdown>
                    ```clj
                    ; the second variant takes an additional starting value.
                    ; it applies the function to the starting value and the first 
                    ; element of the sequence.
                    ; from there on it works as above 
                    (reduce + 1 [2 3])
                    ;=> 6

                    ; let's say i want to convert a vector into a map
                    ; with vector elements as keys and their string
                    ; representation as values.
                    ; that is convert
                    ; [1 2 3 4 :a]
                    ; into
                    ; {1 "1", 2 "2", 3 "3", 4 "4", :a ":a"}
                    ```
                </section>

                <section data-markdown>
                    ```clj
                    (reduce (fn [acc x] (assoc acc x (str x)))
                      {}
                      [1 2 3 4 :a])

                    (apply hash-map
                      (flatten (map (fn [x] [x (str x)])
                                 [1 2 3 4 :a])))

                    (into {}
                      (map (fn [x] [x (str x)])
                           [1 2 3 4 :a]))
                    ```
                </section>

	              <section>
	                  <h3>Sequence abstraction and core functions</h3>
	                  <ul>
	                      <li>Did you notice that map returns you a list when you gave it a vector ?</li>
	                      <li>Do you think we could map or reduce over a hash map ?</li>
	                  </ul>
	              </section>

	              <section>
	                  <h3>Sequence abstraction and core functions</h3>
	                  <ul>
	                      <li>All data structures in clojure support the sequence abstraction</li>
	                      <li>Simply put - they respond to first, rest and cons functions</li>
                        <li>Any data structure that supports these functions will work with map, reduce and all the zillions of other functions in the clojure library</li> 
	                  </ul>
	              </section>

                <section data-markdown>
                    ```clj
                    ; lists, vectors, sets, maps all implement the sequence
                    ; abstraction hence all work with map
                    (defn add-title 
                      [s] 
                      (str "Mr. " s))

                    (map add-title ["Ram" "Shyam"])
                    ;=> ("Mr. Ram" "Mr. Shyam")

                    (map add-title '("Ram" "Shyam"))
                    ;=> ("Mr. Ram" "Mr. Shyam")
                    ```
                </section>

                <section data-markdown>
                    ```clj
                    ; lists, vectors, sets, maps all implement the sequence
                    ; abstraction hence all work with map
                    (defn add-title 
                      [s] 
                      (str "Mr. " s))

                    (map add-title #{"Ram" "Shyam"})
                    ;=> ("Mr. Ram" "Mr. Shyam")

                    (map add-title {:name-1 "Ram" :name-2 "Shyam"})
                    ;=> ("Mr. [:name-1 \"Ram\"]" "Mr. [:name-2 \"Shyam\"]")

                    (map #(add-title (second %)) {:name-1 "Ram" :name-2 "Shyam"})
                    ;=> ("Mr. Ram" "Mr. Shyam")
                    ```
                </section>

                <section data-markdown>
                    ```clj
                    ; what clojure does under the hood is a type conversion  
                    ; on the data structure to convert it into a sequence 

                    (seq ["Ram" "Shyam"])
                    ;=> ("Ram" "Shyam")

                    (seq '("Ram" "Shyam"))
                    ;=> ("Ram" "Shyam")

                    (seq #{"Ram" "Shyam"})
                    ;=> ("Ram" "Shyam")

                    (seq {:name-1 "Ram" :name-2 "Shyam"})
                    ;=> ([:name-1 "Ram"] [:name-2 "Shyam"])
                    ```
                </section>

	              <section>
	                  <h3>Sequence abstraction and core functions</h3>
	                  <ul>
	                      <li>We will now take a look at a number of sequence functions</li>
	                      <li>Some like map and reduce we explore further</li>
                        <li>Others we will see for the first time like take, drop, filter, etc</li> 
	                  </ul>
	              </section>

                <section data-markdown>
                    ```clj
                    ; rest returns a seq of items after the first
                    (rest [1 2 3 4])
                    ;=> (2 3 4)

                    ; next also returns a seq of items after the first
                    (next [1 2 3 4])
                    ;=> (2 3 4)

                    ; so what's the difference between the two ?
                    ```
                </section>

                <section data-markdown>
                    ```clj
                    ; next returns nil when there are no more items,
                    ; rest returns the empty list
                    (rest [1])
                    ;=> ()
                    (next [1])
                    ;=> nil

                    ; when would you prefer one over the other ?
                    ; in boolean conditions since () is logical true
                    ```
                </section>

                <section data-markdown>
                    ```clj
                    ; map can take multiple collections
                    ; make sure your function can handle as many arguments
                    ; as there are collections
                    (map str
                      ["Mr. " "Mrs. " "Miss. "]
                      ["Abhishek" "Aishwarya" "Aaradhya"])
                    ;=> ("Mr. Abhishek" "Mrs. Aishwarya" "Miss. Aaradhya")

                    ; you can even pass a collection of functions to map
                    (map #(vector (% ()) (% []) (% {}))
                      [seq count])
                    ;=>([nil nil nil] [0 0 0])
                    ```
                </section>

                <section data-markdown>
                    ```clj
                    ; open the file map_membership_test.clj
                    ; and make the test cases pass

                    ; remember a property of hash maps
                    ; they can act as functions
                    ({:a 1 "a" 2} :a)
                    ;=> 1
                    ({:a 1 "a" 2} "a")
                    ;=> 2
                    ({:a 1 "a" 2} "b")
                    ;=> nil
                    ```
                </section>

                <section>
                    <pre><code data-sample="code/files/map_membership_test.clj#4-13">
                    </code></pre>
                </section>

                <section data-markdown>
                    ```clj
                    ; open the file map_indexed_test.clj
                    ; and make the test cases pass
                    ; hint: (doc map-indexed)
                    ```
                </section>

                <section>
                    <pre><code data-sample="code/files/map_indexed_test.clj#4-17">
                    </code></pre>
                </section>


                <section data-markdown>
                    ```clj
                    ; reduce can be used to transform the values of a hash map
                    (reduce (fn [new-map [key val]]
                              (assoc new-map key (inc val)))
                      {}
                      {:max 30 :min 10})
                    ;=> {:max 31, :min 11}

                    ; you can even use it to filter values
                    (reduce (fn [new-map [key val]]
                              (if (and (> val 10) (< val 30))
                                new-map
                                (assoc new-map key val)))
                      {}
                      {:max 30 :min 10 :intermediate 20})
                    ;=> {:max 30, :min 10}
                    ```
                </section>

                <section data-markdown>
                    ```clj
                    ; open the file reduce_factorial_test.clj
                    ; and make the test cases pass

                    ; hint: range is a function to produce a sequence 
                    ;       of numbers in increasing order e.g. (range 1 10)

                    ```
                </section>

                <section>
                    <pre><code data-sample="code/files/reduce_factorial_test.clj#4-17">
                    </code></pre>
                </section>

                <section data-markdown>
                    ```clj
                    ; take - takes only  the first n elements from a sequence 
                    ; drop - drops the first n
                    (take 3 [1 2 3 4 5 6 7 8 9 10])
                    ;=> (1 2 3)

                    (drop 3 [1 2 3 4 5 6 7 8 9 10])
                    ;=> (4 5 6 7 8 9 10)

                    ; can you guess the output of this ?
                    (take 10 (range))
                    ```
                </section>

                <section data-markdown>
                    ```clj
                    ; take-while and drop-while are more interesting.
                    ; they drop/take from a sequence while a predicate function
                    ; is true
                    (take-while neg? [-2 -1 0 1 2 3])
                    ;=> (-2 -1)

                    ; take while the item is included in the set.
                    ; using set as a predicate function is a common idiom
                    (take-while #{1 2 3} [1 1 2 2 3 3 1 4 4 5])
                    ;=> (1 1 2 2 3 3 1)

                    (drop-while neg? [-1 -2 -6 -7 1 2 3 4 -5 -6 0 1])
                    ;=> (1 2 3 4 -5 -6 0 1)
                    ```
                </section>

                <section data-markdown>
                    ```clj
                    ; open the file seq_splitter.clj
                    ; and make the test cases pass.
                    ```
                </section>

                <section>
                    <pre><code data-sample="code/files/seq_splitter_test.clj#4-17">
                    </code></pre>
                </section>

                <section data-markdown>
                    ```clj
                    ; filter returns all items from a sequence for which
                    ; the predicate function returns true
                    (filter (fn [x] (= (count x) 1))
                      ["a" "aa" "b" "n" "f" "lisp" "clojure" "q" ""])
                    ;=> ("a" "b" "n" "f" "q")

                    ; remove removes the items for which the predicate 
                    ; returns true
                    (remove nil? [1 nil 2 nil 3 nil])
                    ;=> (1 2 3)

                    (remove (fn [x] (= (count x) 1))
                      ["a" "aa" "b" "n" "f" "lisp" "clojure" "q" ""])
                    ;=> ("aa" "lisp" "clojure" "")
                    ```
                </section>

                <section data-markdown>
                    ```clj
                    ; open the file an_odd_filter_test.clj
                    ; and make the test cases pass.

                    ; hint: if you think a function with a certain name
                    ;       may exist use the apropos function to search
                    ;       the docs e.g. (apropos "filter") and (doc filter)
                    ;       do you think there could exist a function
                    ;       we could use ?
                    ```
                </section>

                <section>
                    <pre><code data-sample="code/files/an_odd_filter_test.clj#4-17">
                    </code></pre>
                </section>

                <section data-markdown>
                    ```clj
                    ; sort allows you to sort a collection by using
                    ; a comparator
                    ; when no comparator is given it uses compare which 
                    ; sorts in increasing order for numbers and dictionary
                    ; order for strings
                    (sort [5 1 2])
                    ;=> (1 2 5)

                    (sort > [5 1 2])
                    ;=> (5 2 1)
                    ```
                </section>

                <section data-markdown>
                    ```clj
                    ; if your sorting needs are more complicated use sort-by
                    ; sort-by applies a function and uses the result to
                    ; to compare the items
                    (sort-by last {:b 1 :c 3 :a 2})
                    ;=> ([:b 1] [:a 2] [:c 3])

                    (sort-by last > {:b 1 :c 3 :a 2})
                    ;=> ([:c 3] [:a 2] [:b 1])
                    ```
                </section>

                <section data-markdown>
                    ```clj
                    ; open the file sort_size_test.clj
                    ; and make the test cases pass.
                    ```
                </section>

                <section>
                    <pre><code data-sample="code/files/sort_size_test.clj#4-17">
                    </code></pre>
                </section>

                <section data-markdown>
                    ```clj
                    ; concat is a function that appends one sequence to 
                    ; the end of another
                    (concat [1 2] [3 4])
                    ;=> (1 2 3 4)

                    (concat "abc" "def")
                    ;=> (\a \b \c \d \e \f)

                    ; can anyone tell me what happened above ?
                    ```
                </section>


	              <section>
	                  <h3>Collection abstraction</h3>
	                  <ul>
	                      <li>The collection abstraction looks at the data structure as a whole</li>
	                      <li>As opposed to the sequence abstraction which looked at individual elements</li>
                        <li>Clojure data structures take part in both abstractions</li> 
	                  </ul>
	              </section>

                <section data-markdown>
                    ```clj
                    ; count, empty? and every? are collection functions

                    (empty? [1 2])
                    ;=> false

                    (every? neg? [-1 -2 -3])
                    ;=> true

                    ; there also exist functions not-every? and not-any? 
                    ```
                </section>

                <section data-markdown>
                    ```clj
                    ; into converts from one type to another.
                    ; if you want to convert from a sequence to a vector
                    ; maybe because you want the original type and not a sequence
                    (into [] (map inc [1 2 3]))
                    ;=> [2 3 4]

                    (into {} (map identity {:name "Rich Hickey"}))

                    ; you can also convert to a different type than the 
                    ; original 
                    (into #{} (map identity [:a :a :b]))
                    ;=> #{:b :a}
                    ```
                </section>

                <section data-markdown>
                    ```clj
                    ; open the file odd_values_gone_test.clj
                    ; and make the test cases pass.
                    ```
                </section>

                <section>
                    <pre><code data-sample="code/files/odd_values_gone_test.clj#4-17">
                    </code></pre>
                </section>

	              <section>
                    <p>Let's take a look at a few more useful core functions....</p>
	              </section>

                <section data-markdown>
                    ```clj
                    ; apply can be used to apply a function over arguments
                    ; supplied in a list
                    (apply max [0 3 2])
                    ;=> 3

                    ; this also works 
                    (apply max 1 2 [3 4])
                    ;=> 4
                    ```
                </section>

                <section data-markdown>
                    ```clj
                    ; open the file apply_factorial_test.clj
                    ; and make the test cases pass

                    ; hint: range is a function to produce a sequence 
                    ;       of numbers in increasing order e.g. (range 1 10)
                    ```
                </section>

                <section>
                    <pre><code data-sample="code/files/apply_factorial_test.clj#4-17">
                    </code></pre>
                </section>

	              <section>
                    <p>In the following two exercises we will work with functions we have not seen till now</p>
                    <p>You will need to read the documentation to see how they work</p>
	              </section>

                <section data-markdown>
                    ```clj
                    ; open the file consecutive_duplicates_test.clj
                    ; and make the test cases pass
                    ```
                </section>

                <section>
                    <pre><code data-sample="code/files/consecutive_duplicates_test.clj#4-17">
                    </code></pre>
                </section>

                <section data-markdown>
                    ```clj
                    ; open the file mapped_by_type_test.clj
                    ; and make the test cases pass
                    ```
                </section>

                <section>
                    <pre><code data-sample="code/files/mapped_by_type_test.clj#4-18">
                    </code></pre>
                </section>

                <section>
	                  <h3>Side Note - Simplicity</h3>
	                  <blockquote>
	                      It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.<br>—Alan Perlis
	                  </blockquote>
	                  <ul>
	                      <li>Reach for built in data structures first</li>
	                      <li>Clojure provides a rich set of functions that work with the data structures</li>
	                      <li>Keep Alan Perlis in mind as we continue our exploration</li>
	                  </ul>
	              </section>

	              <section>
	                  <h3>Functions as first class objects</h3>
	                  <ul>
	                      <li>Can be created on demand</li>
	                      <li>Can be stored in a data structure</li>
                        <li>Can be passed as an argument to a function</li> 
                        <li>Can be returned as the value of a function</li> 
	                  </ul>
	              </section>

                <section data-markdown>
                    ```clj
                    ; composition allows us to create functions on demand
                    ; comp takes any number of functions then applies the 
                    ; rightmost to the args, the next to the result and so on
                    ((comp str +) 5 6 7) 
                    ;=> "18"

                    ; who can tell me what the below code will do ?

                    (filter (comp zero? second) {:a 1 :b 2 :c 0 :d 4 :e 0})
                    ```
                </section>

                <section data-markdown>
                    ```clj
                    ; sometimes you may want to build new functions from partial 
                    ; application of others
                    ; partial takes a function and fewer than normal arguments
                    ; and returns a function that can accept variable number 
                    ; of arguments
                    ((partial + 1) 2 3)
                    ;=> 6

                    ; complement is another function that changes behavior
                    ; of a function
                    ; complement toggles the return value of functions
                    ; returning boolean values
                    (filter (complement even?) [1 2 3 4 5])
                    ;=> (1 3 5)
                    ```
                </section>

                <section data-markdown>
                    ```clj
                    ; since clojure functions are first class they are also data.
                    ; you can store functions in data structure
                    [seq + - count]

                    ; compare this with other languages where we have a line
                    ; between what is data and what are things that operate on
                    ; that data
                    ```
                </section>

                <section data-markdown>
                    ```clj
                    ; clojure functions can be passed as arguments to functions
                    ; or returned as values from functions
                    ; this is called higher order programming and we have already
                    ; seen this in action with map, reduce, sort, etc
                    ```
                </section>

                <section data-markdown>
                    ```clj
                    ; let's look at a function that returns a function
                    ; and along the way we will also see a cool feature
                    ; called closure
                    (defn times-n
                      [n]
                      (fn [x] (* n x)))

                    (def times-2 (times-n 2))

                    (times-2 10)
                    ;=> 20

                    (def times-4 (times-n 4))

                    (times-4 10)
                    ;=> 40
                    ```
                </section>

                <section data-markdown>
                    ```clj
                    ; open the file divisible_n_test.clj
                    ; and make the test cases pass
                    ```
                </section>

                <section>
                    <pre><code data-sample="code/files/divisible_n_test.clj#4-18">
                    </code></pre>
                </section>

                <section data-markdown>
                    ```clj
                    (defn divisible-by-n 
                      [n]
                      (fn [num] (zero? (rem num n))))

                    (defn divisible-by-n 
                      [n]
                      (fn [num] (= 0 (mod num n))))
                    ```
                </section>

                <section data-markdown>
                    ```clj
                    ; memoize keeps a mapping from the arguments to results
                    ; giving you higher performance at expense of memory
                    (defn fib [n]
                      (condp = n
                        0 1
                        1 1
                        (+ (fib (dec n)) (fib (- n 2)))))

                    (time (fib 30))
                    ;=> "Elapsed time: 73.262877 msecs"
                    ;=> 1346269
                    ```
                </section>

                <section data-markdown>
                    ```clj
                    ; we can easily memoize it
                    (def m-fib (memoize fib))

                    (time (m-fib 30))
                    ;=> "Elapsed time: 27.334791 msecs"
                    ;=> 1346269
                    ```
                </section>

                <section>
                    <h3>Laziness</h3>
                    <ul>
                        <li>A language is lazy if it performs any operation only when it's result is required</li>
                        <li>Clojure is a partially lazy language</li>
                        <li>Clojure is lazy in the way it handles sequences</li>
                    </ul>
	              </section>

                <section data-markdown>
                    ```clj
                    (defn slow-inc
                      [n]
                      (Thread/sleep 1000)
                      (inc n))

                    ; let's map this over a sequence of
                    ; 1000 elements.
                    ; with a sleep of a second the whole operation 
                    ; should take roughly 16 minutes
                    (time
                      (def a (map slow-inc (range 1 1001)))
                    ```
                </section>

                <section data-markdown>
                    ```clj
                    ; now let's try to take the first element from this sequence
                    (time (first a))

                    ; the output is something unexpected
                    ; let's try to explain it

                    ; lazy sequences only need to be realized once
                    ; below returns instantaneously
                    (time (first a))
                    ```
                </section>

                <section data-markdown>
                    ```clj
                    ; laziness allows you to work with infinite sequences
                    ; and as we will see it can provide elegant solutions
                    ; for some hard problems

                    ; range is the simplest lazy sequence function
                    ; without any arguments it produces an infinite sequence
                    ; try this on the repl though beware you will have
                    ; to kill the repl
                    (range)
                    ``` 
                </section>

                <section data-markdown>
                    ```clj
                    ; we can take as many elements as we want from a lazy
                    ; sequence
                    (take 5 (range))

                    ; we can also chain our lazy sequence producing functions
                    (take 10 (filter odd? (range)))
                    ``` 
                </section>

                <section data-markdown>
                    ```clj
                    ; open the file my_indexed_test.clj
                    ; and make the test cases pass

                    ``` 
                </section>

                <section>
                    <pre><code data-sample="code/files/my_indexed_test.clj#4-18">
                    </code></pre>
                </section>

                <section data-markdown>
                    ```clj
                    ; let's look at the solution
                    (defn my-indexed 
                      [coll] 
                      (map (fn [elt idx] [idx elt]) 
                        coll 
                        (range)))
                    ``` 
                </section>

                <section data-markdown>
                    ```clj
                    ; another simple lazy function is repeat
                    ; it will just return an infinite sequence of
                    ; argument supplied
                    (take 5 (repeat "hello"))

                    ; repeatedly is another one which calls the supplied
                    ; function and returns infinite sequence of values
                    ; returned
                    (take 5 (repeatedly (fn [] (rand-int 10))))
                    ;=> (6 6 6 9 2)
                    ``` 
                </section>

                <section data-markdown>
                    ```clj
                    ; iterate takes a function and a starting value
                    ; and applies the function to the starting value,
                    ; then to the value returned and so on
                    ; x, (f x), (f (f x))....
                    (take 5 (iterate inc 0))
                    ;=> (0 1 2 3 4)
                    ``` 
                </section>

                <section>
                    <h2>Tower Of Hanoi - Revisited</h2>
                    <img src="resources/images/tower_of_hanoi.jpg" width="500" height="500">
                </section>

                <section>
                    <p>$$T_0 = 0$$</p>
                    <p>$$T_n = 2.T_{n-1} + 1$$</p>
                    <p>Can you write a function that returns a lazy sequence of moves required ?</p>
                    <p>hint: iterate</p>
                </section>

                <section data-markdown>
                    ```clj
                    ; open the file iterate_hanoi_test.clj
                    ; and make the test cases pass
                    ```
                </section>

                <section>
                    <pre><code data-sample="code/files/iterate_hanoi_test.clj#4-25">
                    </code></pre>
                </section>

                <section data-markdown>
                    ```clj
                    ; let's take a look at the lazy version
                    (defn iterate-hanoi
                      [n]
                      (nth (iterate #(+ (*' 2 %) 1)
                             0)
                        n))

                    ; and this is the recursive version
                    (defn hanoi [n]
                      (if (= 0 n)
                        0
                        (inc (*' 2 (hanoi (dec n))))))
                    ```
                </section>

                <section>
                    <p>using lazy sequences is nice but can I create my own ?</p>
                </section>

                <section data-markdown>
                    ```clj
                    ; this is a recursive function for creating a seq
                    ; of odd numbers

                    (defn odd-numbers
                      ([] (odd-numbers 1))
                      ([n] (cons n (odd-numbers (+ n 2)))))

                    (take 1000 (odd-numbers))
                    => StackOverflowError
                    ```
                </section>

                <section data-markdown>
                    ```clj
                    ; using lazy-seq you can create your own lazy seqs.
                    ; wrap your lazy sequence producing code in lazy-seq.
                    ; use cons to create the sequence

                    (defn odd-numbers
                      ([] (odd-numbers 1))
                      ([n] (lazy-seq (cons n (odd-numbers (+ n 2))))))

                    ; notice above that what looks like a recursive call is
                    ; actually a closure over it's input and not a recursive
                    ; call
                    ```
                </section>

                <section data-markdown>
                    ```clj
                    ; open the file my_iterate_test.clj
                    ; and make the test cases pass
                    ```
                </section>

                <section>
                    <pre><code data-sample="code/files/my_iterate_test.clj#5-25">
                    </code></pre>
                </section>

                <section>
                    <h2>Data oriented programming</h2>
				        </section>

                <section>
                    <ul>
                        <li>OO and imperative languages enforce a seperation between data and code</li>
                        <li>But try to reduce the friction by inventing things like ORM</li>
                    </ul>
				        </section>

                <section>
                    <p>Let's talk about how functional programmers look at a problem
                        <ul>
                            <li>Data</li>
                            <li>Data</li>
                        </ul>
                    </p>
                </section>

                <section>
                    <p>Functional programming languages promote value oriented programming</p>
                    <ul>
                        <li>5 is a value</li>
                        <li>{:a 1, :b 2} is also a value</li>
                    </ul>
                    <p>Remember that values are immutable</p>
	              </section>

                <section>
                    <p>Immutability of values has these benefits</p>
                    <ul>
                        <li>Reasonable — no need to worry about change over time.</li>
                        <li>Equality — equal values are always equal, forever.</li>
                        <li>Inexpensive — reference sharing is cheaper than defensive copying.</li>
                        <li>Flatness — all subcomponents of a value are also values.</li>
                        <li>Sharing — sharing values across threads or in a cache is stress-free.</li>
                    </ul>
	              </section>

                <section data-markdown>
                    ```clj
                    ; values can be reproduced and fabricated
                    ; the textual form of a map is exactly what it looks like
                    {:a 1, :b 2}
                    ```
                    ```java
                    Map<String,Integer> stuff = new HashMap<String,Integer>() {{
                       put("a", 1);
                       put("b", 2);
                    }};
                    ```
                </section>

                <section data-markdown>
                    ```clj
                    ; values facilitate testing
                    ; unit tests are very clear when we use values as input
                    ; to pure functions
                    ; (assert (= [1 2 3] (conj [1 2] 3)))

                    ; this also extends to generative testing where you let
                    ; the system generate input test data for you
                    ```
                </section>

                <section data-markdown>
                    ```clj
                    ; values facilitate debugging
                    ; logging values makes it much easier to see
                    ; what is happening in a system.
                    ; compare this to a log which shows you what
                    ; class or function got called
                    ```
                </section>

                <section>
                    <h2>Macros</h2>
                    <h3>Code that writes code</h3>
				        </section>

                <section data-markdown>
                    ```clj
                    ; in programming languages like java or c
                    ; the compiler translates your program text
                    ; into an intermediate form called the AST but
                    ; this AST is not accessible to you, the programmer

                    ; in clojure and other lisps the textual representation
                    ; of your code is coverted to a list data structure which
                    ; is the AST
                    ; hence, in clojure all your code is data
                    ```
                </section>

                <section data-markdown>
                    ```clj
                    (eval (list + 1 2))
                    ;=> 3

                    ; note that eval works on a list data structure
                    ; not a textual representation of it.

                    (eval (concat (list + 1 2) [10]))
                    ;=> 13
                    ```
                </section>

                <section data-markdown>
                    ```clj
                    (eval (list 'def 'lucky-number (concat (list + 1 2) [10])))
                    ;=> #'user/lucky-number
                    lucky-number
                    ;=> 13

                    ; code generators in other languages generate text,
                    ; but manipulating data is more powerful than manipulating
                    ; text

                    ```
                </section>

                <section data-markdown>
                    ```clj
                    ; macros are code that return lists to be evaluated
                    ; by the clojure interpreter
                    (defmacro infix
                      [[left-operand operator right-operand]]
                      (list operator left-operand right-operand))

                    (infix (2 + 3))

                    ; the arguments to a macro are not evaluated.
                    ; try writing infix as a normal function
                    ```
                </section>

                <section data-markdown>
                    ```clj
                    ; we can create lists in macros using list
                    ; but there's another way.
                    ; the syntax quote
                    (eval (list 'def 'lucky-number (concat (list + 1 2) [10])))
                    ;=> #'user/lucky-number
                    lucky-number
                    ;=> 13

                    (macroexpand-1
                      (list 'def 'lucky-number (concat (list '+ 1 2) [10])))
                    ;=> (def lucky-number (+ 1 2 10))

                    (macroexpand-1 `(def lucky-number ~(concat '(+ 1 2) [10])))
                    ;=> (def user/lucky-number (+ 1 2 10))

                    ```
                </section>

                <section data-markdown>
                    ```clj
                    ; if you want to see how our infix macro looks like
                    ; syntax quote, here it is
                    (defmacro infix
                      [[left-operand operator right-operand]]
                      `(~operator ~left-operand ~right-operand))

                    (infix (2 + 3))
                    ```
                </section>

                <section data-markdown>
                    ```clj
                    ; another macro
                    (defmacro on-debug
                      [& body]
                      `(when DEBUG (do ~@body)))

                    (def DEBUG false)

                    (on-debug (println "hello"))
                    ;=> nil

                    (macroexpand-1 '(on-debug (println "hello")))
                    ;=> (clojure.core/when user/DEBUG (do (println "hello")))
                    ```
                </section>

                <section data-markdown>
                    ```clj
                    ; that seems vaguely cool, but why should you care ?
                    ; macros let the programmer extend the langauge to
                    ; fit your problem domain.

                    ; even clojure defines lots of essential functionality
                    ; as macros - and, or, when
                    ```
                </section>

                <section data-markdown>
                    ```clj
                    ; this was some heavy stuff
                    ; let's take a break by writing some code

                    ; open the file remove_duplicates_test.clj
                    ; and make the test cases pass
                    ```
                </section>

                <section>
                    <pre><code data-sample="code/files/remove_duplicates_test.clj#4-25">
                    </code></pre>
                </section>

                <section data-markdown>
                    ```clj
                    ; this is my answer
                    (defn remove-consec-duplicates
                      [x]
                      (map first (partition-by identity x)))
                    ```
                </section>


                <section>
                    <h2>Design Patterns</h2>
                    <h3>Or why functional programmers never talk about them</h3>
				        </section>

                <section>
                    <p>Popularized by the Gang Of Four or GoF book</p>
                    <p>Provide solutions to common problems faced by programmers</p>
                    <p>Were supposed to be guidelines, but have become a religion now</p>
				        </section>

                <section>
                    <p>Not everyone will agree with this.......</p>
                    <p>Design patterns are not universal principles but address deficiencies of some languages</p>
                    <p>Functional programming languages just don't need them</p>
				        </section>

                <section data-markdown>
                    <script type="text/template">
                     <h2>Everyone&rsquo;s favorite design pattern</h2>
                     <p class="fragment step-fade-in-then-out">The Global Variable</p>
                     <p class="fragment fade-in">Singleton</p>
                    </script>
	              </section>

                <section data-markdown>
                    ```java
                    public final class UIConfig {
                      public static final UIConfig INST = new UIConfig("ui.conf");

                      private String backgroundStyle;
                      private String fontStyle;

                      private UIConfig(String configFile) {
                        loadConfig(configFile);
                      }

                      private static void loadConfig(String file) {
                        INST.backgroundStyle = "black";
                        INST.fontStyle = "Arial";
                      }

                      public String getBackgroundStyle() {
                        return backgroundStyle;
                      }

                      public String getFontStyle() {
                        return fontStyle;
                      }
                    }
                    ```
                </section>

                <section data-markdown>
                    ```clj
                    (def ui-config (load-config "ui.config"))

                    (defn load-config [config-file]
                      ;; process config file and return map with configuratios
                      {:bg-style "black" :font-style "Arial"})
                    ```
                </section>

                <section>
                    <h2>Iterator Pattern</h2>
                    <p>Wikipedia says</p>
                    <p>In object-oriented programming, the iterator pattern is a design pattern in which an iterator is used to traverse a container and access the container&rsquo;s elements. </p>
                    <p>The iterator pattern decouples algorithms from containers; in some cases, algorithms are necessarily container-specific and thus cannot be decoupled.</p>
                </section>

                <section data-markdown>
                    ```clj
                    ; the sequence abstraction in clojure provides this
                    (seq [1 2 3])
                    ;=> (1 2 3)

                    (seq {:a 1, :b 2})
                    ;=> ([:a 1] [:b 2])

                    (seq #{7 8 9})
                    ;=> (7 8 9)
                    ```
                </section>

                <section>
                    <h2>Strategy Pattern</h2>
                    <p>Wikipedia says</p>
                    <p>The strategy pattern (also known as the policy pattern) is a behavioral software design pattern that enables selecting an algorithm at runtime.</p>
                    <p>Instead of implementing a single algorithm directly, code receives run-time instructions as to which in a family of algorithms to use.</p>
                </section>

                <section data-markdown>
                    ```java
                    // we want to sort users by whether they are subscribers
                    // and then name
                    class SubsComparator implements Comparator<User> {
                      @Override
                      public int compare(User u1, User u2) {
                        if (u1.isSubscription() == u2.isSubscription()) {
                          return u1.getName().compareTo(u2.getName());
                        } else if (u1.isSubscription()) {
                           return -1;
                        } else {
                          return 1;
                        }
                      }
                    }
                    ```
                </section>

                <section data-markdown>
                    ```java
                    class ReverseSubsComparator implements Comparator<User> {
                      @Override
                      public int compare(User u1, User u2) {
                        if (u1.isSubscription() == u2.isSubscription()) {
                          return u2.getName().compareTo(u1.getName());
                        } else if (u1.isSubscription()) {
                           return -1;
                        } else {
                           return 1;
                        }
                      }
                    }
                    ```
                </section>

                <section data-markdown>
                    ```java
                    // forward sort
                    Collections.sort(users, new SubsComparator());

                    // reverse sort
                    Collections.sort(users, new ReverseSubsComparator());
                    ```
                </section>

                <section data-markdown>
                    ```clj
                    ;; forward sort
                    (sort-by (juxt (complement :subscription) :name) users)

                    ;; reverse sort
                    (sort-by (juxt :subscription :name) #(compare %2 %1) users)
                    ```
                </section>

                <section data-markdown>
                    ```clj
                    (def users [{:name "ram" :subscription true}
                                {:name "rahim" :subscription true}
                                {:name "lakhan" :subscription false}])

                    (sort-by (juxt (complement :subscription) :name) users)
                    ;=> ({:name "rahim", :subscription true}
                         {:name "ram", :subscription true}
                         {:name "lakhan", :subscription false})

                    (sort-by (juxt :subscription :name) #(compare %2 %1) users)
                    ;=> ({:name "ram", :subscription true}
                         {:name "rahim", :subscription true}
                         {:name "lakhan", :subscription false})
                    ```
                </section>

                <section>
                    <h2>Prototype Pattern</h2>
                    <p>Wikipedia says</p>
                    <p>The prototype pattern is a creational design pattern in software development. It is used when the type of objects to create is determined by a prototypical instance, which is cloned to produce new objects.</p>
                </section>


                <section>
                    <h2>Prototype Pattern</h2>
                    <p>Wikipedia says</p>
                    <p>This pattern is used to
                        <ul>
                            <li>avoid subclasses of an object creator in the client application, like the factory method pattern does.</li>
                            <li>avoid the inherent cost of creating a new object in the standard way (e.g., using the new keyword) when it is prohibitively expensive for a given application.</li>
                        </ul>
                    </p>
                </section>

                <section data-markdown>
                    ```java
                    public class User implements Cloneable {
                      private String name = "ZZZ";
                      private String email = "zzz@gmail.com";
                      private Date dateOfBirth = new Date(1970, 1, 1);
                      private int weight = 60;
                      private Gender gender = Gender.MALE;
                      private Status status = Status.SINGLE;
                      private List<Child> children = Arrays.asList(new Child(Gender.FEMALE));
                      private double monthSalary = 1000;
                      private List<Brand> favouriteBrands = Arrays.asList("Adidas", "GAP");
                      // few hundreds more properties
                      .
                      .
                    }
                    ```
                </section>

                <section data-markdown>
                    ```java
                    public class User implements Cloneable {
                      @Override
                      protected User clone() throws CloneNotSupportedException {
                        User prototyped = new User();
                        prototyped.name = name;
                        prototyped.email = email;
                        prototyped.dateOfBirth = (Date)dateOfBirth.clone();
                        prototyped.weight = weight;
                        prototyped.status = status;
                        List<Child> childrenCopy = new ArrayList<Child>();
                        for (Child c : children) { 
                          childrenCopy.add(c.clone());
                        }
                        prototyped.children = childrenCopy;
                        prototyped.monthSalary = monthSalary;
                        List<String> brandsCopy = new ArrayList<String>();
                        for (String s : favouriteBrands) {
                          brandsCopy.add(s);
                        }
                        prototyped.favouriteBrands = brandsCopy;
                        return  prototyped;
                    }
                    ```
                </section>

                <section>
                    <h2>Prototype Pattern</h2>
                    <p>Note that
                        <ul>
                            <li>you need to do a deep copy</li>
                            <li>every class needs to implement clone</li>
                        </ul>
                    </p>
                </section>

                <section data-markdown>
                    ```clj
                    (def registration-prototype
                      {:name          "ZZZ"
                       :email         "zzz@gmail.com"
                       :date-of-birth "1970-01-01"
                       :weight        60
                       :gender        :male
                       :status        :single
                       :children      [{:gender :female}]
                       :month-salary  1000
                       :brands        ["Adidas" "GAP"]})
                    ```
                </section>

                <section data-markdown>
                    ```clj
                    ;; return new object
                    (assoc registration-prototype
                      :name "Khushi Kumari Gupta"
                      :email "tomato@gmail.com"
                      :weight 52
                      :gender :female
                      :month-salary 1000000000)
                    ```
                </section>

                <!-- <section data-markdown>
                    Side Note
                    thrush operator
                    -----
                    ```clj
                    ; the thrush operator or thread first macro, in simple terms,
                    ; let's you rearrange code

                    ; let's look at a simple example
                    ; say i have a symbol c on which i want to perform the operations 
                    ; as below
                    (def c 5)
                    (- (/ (+ c 3) 2) 1)

                    ; using the thread first macro i could rewrite this as
                    (-> c
                    (+ 3)
                    (/ 2)
                    (- 1))
                    ```
                </section>
                -->


                <!-- <section data-markdown>
                    Side Note
                    thrush operator
                    -----
                    ```clj
                    ; let's take a look at another example
                    (use 'clojure.string)
                    (split (replace (upper-case "a b c d") "A" "X") #" ")

                    ; using the thread first macro we can write this code as
                    (-> "a b c d"
                    upper-case
                    (replace "A" "X")
                    (split #" "))

                    ; note that it's ok to omit the parentheses if the function
                    ; takes only one argument
                    ```
                </section>
                -->

                <!-- section data-markdown>
                    ```clj
                    ; can you make the below test pass ?

                    (= (__ (sort (rest (reverse [2 5 4 1 3 6]))))
                    (-> [2 5 4 1 3 6] 
                    reverse 
                    rest 
                    sort 
                    __)
                    5)
                    ```
                </section-->

                <!--section data-markdown>
                    Side Note
                    thread last macro
                    -----
                    ```clj
                    ; the thread last macro inserts the form as the last argument,
                    ; making a list of it if not already so

                    ; let's rearrange the below code to use ->>
                    (reduce +
                    (take 10
                    (filter even?
                    (map #(* % %) (range)))))

                    (->> (range)
                    (map #(* % %))
                    (filter even?)
                    (take 10)
                    (reduce +))
                    ```
                </section-->

                <!--section data-markdown>
                    ```clj
                    ; can you make the below test case pass ?
                    (= (__ (map inc (take 3 (drop 2 [2 5 4 1 3 6]))))
                    (->> [2 5 4 1 3 6] 
                    (drop 2) 
                    (take 3) 
                    (map inc) 
                    (__))
                    11)
                    ```
                </section-->

                <!--section>
	                  <h3>Concurrency and Parallelism</h3>
                    <ul>
                        <li>Concurrency and parallelism are two related but different things</li>
                        <li>Concurrency is managing multiple tasks</li>
                        <li>Concurrency might be implemented by switching between multiple tasks running on one processor</li>
                        <li>Parallelism is a subset of concurrency and entails executing multiple tasks at the same time</li>
                    </ul>
                </section-->


                <!-- section data-markdown>
                    ```clj
                    ; let's first take look at some functions that can 
                    ; parallelize your code without requiring any code changes

                    ; pvalues returns a lazy sequence of values of the expressions
                    ; evaluated in parallel
                    (defn sleeper 
                    [s thing] 
                    (Thread/sleep (* 1000 s))
                    thing)

                    (defn pvs 
                    [] 
                    (pvalues
                    (sleeper 2 :1st)
                    (sleeper 30 :2nd)
                    (keyword "3rd")))
                    ```
                </section-->

                <!-- section data-markdown>
                    ```clj
                    ; let's see how much time it takes to get the first
                    ; value
                    (time (first (pvs)))

                    ;=> "Elapsed time: 2003.992906 msecs"
                    ;=> :1st

                    ; the time taken for the first element is equal to
                    ; the time taken to realize that value
                    ; but we will see that the time taken to realize subsequent
                    ; values is as much as the most expensive element before it.
                    (time (last (pvs)))

                    ;=> "Elapsed time: 30007.241914 msecs"
                    ;=> :3rd
                    ```
                </section-->

                <!-- section data-markdown>
                    ```clj
                    ; the reason for this is that clojure maintains a sliding window
                    ; within which all elements are realized and the total time taken
                    ; is that for the most expensive computation

                    ; generally, the sliding window is of size N + 2, where N is 
                    ; the number of cores
                    ```
                </section-->

                <!-- section data-markdown>
                    ```clj
                    ; the pmap function is the parallel version of the map function
                    ; that we have already seen.
                    ; note the doall to realize the lazy seq
                    (time 
                    (doall
                    (pmap (comp inc (partial sleeper 2)) 
                    [1 2 3])))

                    ;=> Elapsed time: 1992.638618 msecs
                    ;=> (2 3 4)

                    ; the total cost of realizing the sequence is again bound
                    ; by the most expensive operation

                    ; pmap seems to work very well for the above example,
                    ; so should we replace all calls to map with pmap ?
                    ```
                </section-->

                <!-- section data-markdown>
                    ```clj
                    ; let's do an experiment
                    ; define a range of 10 million numbers
                    ; pmap and map over it using a function
                    ; that multiplies each number by itself

                    ; don't forget to use doall

                    ; what is the time taken by pmap ?
                    ; by map ?
                    ```
                </section-->

                <!-- section data-markdown>
                    ```clj
                    (def l (range 10000000))

                    (time (def a (doall (pmap #(* % %) l))))
                    ;=> "Elapsed time: 35843.501162 msecs"

                    (time (def a (doall (map #(* % %) l))))
                    ;=> "Elapsed time: 7848.107447 msecs"
                    ```
                </section-->

                <!-- section data-markdown>
                    ```clj
                    ; whether we should or not replace map with pmap depends
                    ; on the use case.
                    ; there is some overhead associated with sending work off to
                    ; threads, co-ordinating result gathering in proper order.
                    ; if you are sure that your function cost is higher than this 
                    ; overhead then use pmap.

                    ; as with all parallel systems, you have to experiment and see what
                    ; works for your use case. 

                    ```
                </section-->

                <!-- section data-markdown>
                    ```clj
                    ; finally there's the pcalls function which takes an arbitrary 
                    ; number of no argument functions and executes them in parallel
                    (time (doall 
                    (pcalls
                    #(sleeper 2 :first)
                    #(sleeper 3 :second)
                    #(keyword "3rd"))))

                    ;=> "Elapsed time: 3003.252293 msecs"
                    ;=> (:first :second :3rd)            

                    ; pcalls has the same benefits and trade-offs as pvalues and pmap
                    ```
                </section-->

                <section data-markdown>
                    ```clj
                    ; open the file palindrome_detector_test.clj
                    ; and make the test cases pass
                    ```
                </section>
                <section>
                    <pre><code data-sample="code/files/palindrome_detector_test.clj#4-25">
                    </code></pre>
                </section>

                <!-- section>
	                  <h3>Concurrency and Parallelism</h3>
                    <p>Let's get back to our discussion of concurrency by looking at</p>
                    <ul>
                        <li>Futures</li>
                        <li>Delays</li>
                        <li>Promises</li>
                    </ul>
                </section-->


                <!-- section>
	                  <h3>Concurrency and Parallelism</h3>
                    <p>Futures, delays and promises allow us to write concurrent code by decoupling</p>
                    <ul>
                        <li>Task definition</li>
                        <li>Task execution</li>
                        <li>Requiring the task's result</li>
                    </ul>
                </section-->

                <!-- section>
                    <h3>Concurrency and Parallelism</h3>
                    <ul>
                        <li>Our serial code consists of task definitions like <br>(web-api/get-customer 1234)</br></li>
                        <li>As soon as clojure encouters this it executes the task and blocks until the result of the API is available</li>
                        <li>Now let's see how futures, delays and promises let us break this flow</li>
                    </ul>
                </section-->


                <!-- section data-markdown>
                    ```clj
                    ; using futures you can define a task and place it on another
                    ; thread without requiring the result immediately.
                    (future (Thread/sleep 10000)
                    (println "this will print after 10 seconds"))

                    ; notice how the repl can continue executing other tasks
                    ; while the future executes in another thread.

                    ; you can fire off a future and forget about it
                    ; but most likely you are interested in it's result
                    ```
                </section-->

                <!-- section data-markdown>
                    ```clj
                    ; if you noticed when we ran the future we got a funny
                    ; output on the repl immediately.
                    ; a future returns a reference that we can use to query it.

                    ; we can deref a future to get it's value 
                    (let [result (future (println "this will print only once")
                    (+ 1 1))]
                    (println "deref: " (deref result))
                    (println "@: " @result))

                    ; notice that @ is shorthand for deref and dereferencing 
                    ; the future twice executes it only once
                    ```
                </section-->

                <!-- section data-markdown>
                    ```clj
                    ; you can also call realized? on a future to see if it 
                    ; is done running
                    (realized? (future (Thread/sleep 1000)))
                    ; => false

                    (let [f (future)]
                    @f
                    (realized? f))
                    ;=> true

                    ; we can also supply a timeout while dereferncing futures
                    (deref (future (Thread/sleep 1000) 0) 10 5)

                    ; one use case for futures could be to send stuff off to a logging
                    ; function to be executed in another thread
                    ```
                </section-->

                <!--section data-markdown>
                    ```clj
                    ; delays allow you to define a task without
                    ; having to execute it immediately or requiring the
                    ; result
                    (def a-simple-delay
                    (delay (let [message "the message from delay"]
                    (println "First deref:" message)
                    message))) 

                    ; we can start the execution of a delay by using force or @.
                    ; just like futures a delay is executed only once and 
                    ; it's value cached.
                    (force a-simple-delay)

                    ; notice how the first time 2 messages are printed
                    ; and subsequently only the value of the delay is returned
                    @a-simple-delay
                    ```
                </section-->

                <!-- section data-markdown>
                    ```clj
                    ; one use case for delays could be to fire off a function
                    ; to be executed when the first out of multiple futures finishes
                    (let [notify (delay (send-email "blah@gmail.com"))]
                    (doseq [idx (range 10)]
                    (future (do-some-long-work idx)
                    (force notify))))  

                    ; note that even though (force notify) will be executed multiple
                    ; times from different threads the delay body only gets executed once.

                    ```
                </section-->

                <!-- section data-markdown>
                    ```clj
                    ; promises are placeholders for values that can be delivered
                    ; by executing threads later on.
                    ; promises 
                    (def x (promise))
                    (def y (promise))
                    (def z (promise))

                    (future (deliver z (+ @x @y)))

                    (future (Thread/sleep 2000) (deliver x 42))

                    (future (Thread/sleep 2000) (deliver y 42))

                    @z
                    ;=> 84

                    ; promises block if we try to derefernce them before
                    ; a value has been delivered.
                    ; calling deliver multiple times has no effect
                    ```
                </section-->

                <!-- section data-markdown>
                    ```clj
                    ; let's try to see how we can use promises

                    ; we want to fire off a number of tasks but we are only
                    ; interested in a logically true return value
                    (let [my-result (promise)]
                    (doseq [idx (range 10)]
                    (future (if-let [answer (some-function idx)]
                    (deliver my-result answer))))
                    (println "and the answer is: " @my-result))

                    ; note that even though deliver might be called multiple times 
                    ; only the first one has any effect

                    ; also we can provide a time out for the deref
                    ```
                </section-->

                <!-- section data-markdown>
                    ```clj
                    ; another use case for promises is as a callback
                    ; i.e. to execute some piece of code once some 
                    ; other code finishes
                    (let [the-promise (promise)]
                    (future (println "the promised value is:" @the-promise))
                    (Thread/sleep 10000)
                    (deliver the-promise 42))

                    ; here the future will start running immediately but 
                    ; then block waiting for the promise
                    ```
                </section-->


                <!-- section data-markdown>
                    Side Note
                    List comprehension
                    -------------------
                    ```clj
                    ; for in clojure acts like a list comprehension

                    ; let's say i have 2 collections and i want to
                    ; multiply each element of first collection with
                    ; each element of second
                    (def s1 [1 2 3 4 5])
                    (def s2 [1 2 3 4 5])

                    (for [x s1 y s2] (* x y))
                    ;=> (1 2 3 4 5 2 4 6 8 10 3 6 9 12 15 4 8 12 16 20 5 10 15 20 25)

                    ; notice that the right most collection is iterated fastest.

                    ; try writing the above using map

                    ```
                </section-->

                <!-- section data-markdown>
                    Side Note
                    List comprehension
                    -------------------
                    ```clj
                    ; here's what i came up with

                    (mapcat #(map (partial * %) s2) s1)

                    ```
                </section-->

                <!-- section data-markdown>
                    Side Note
                    List comprehension
                    -------------------
                    ```clj
                    ; for supports modifiers let, when and while
                    (for [x [0 1 2 3 4 5]
                    :let [y (* x 3)]
                    :when (even? y)]
                    y)

                    ;=> (0 6 12)

                    (for [x [0 1 2 3 4 5]
                    :let [y (* x 3)]
                    :while (even? y)]
                    y)
                    ;=> (0)

                    ; while stops at the first element that evaluates
                    ; to false

                    ; can you figure out the output of this ?
                    (for [x [0  2  4 5]
                    :let [y (* x 3)]
                    :while (even? y)]
                    y)
                    ```
                </section-->

                <!-- section>
                    <h3>Concurrency and State</h3>
                    <ul>
                        <li>Java and other imperative languages manage shared state concurrency by using locks</li>
                        <li>These locks and mutexes protect access to shared data</li>
                        <li>Let's talk about how Clojure manages mutating state and concurrency</li>
                        <li>But I said clojure has immutable data structures !!!</li>
                    </ul>
                </section-->

                <!-- section>
                    <h3>Concurrency and State</h3>
                    <p>We will take a look at the following clojure reference types</p>
                    <ul>
                        <li>Atoms</li>
                        <li>Refs</li>
                        <li>Agents</li>
                    </ul>
                </section-->

                <!-- section data-markdown>
                    ```clj
                    ; atom is a reference type used to store values
                    ; and atomically update them when required.
                    ; atoms are thread safe and can be used across threads
                    ; as light weight shared data.

                    (def counter (atom 0)) 

                    ; we can use the familiar deref operators to get the
                    ; atom's value
                    @counter
                    (deref counter)

                    ; note that blocking on dereference does not make sense in
                    ; case of atoms. it will always return the atom's current value
                    ```
                </section-->

                <!-- section data-markdown>
                    ```clj
                    ; to update an atom to a new state we use swap!
                    (swap! counter inc)

                    ; dereferencing the atom after a swap! will show 
                    ; the new value
                    @counter
                    ;=> 1

                    ; note that swap! works synchronously so your thread
                    ; will block until the update function returns

                    ; we can also supply a function with multiple arguments
                    (swap! counter * 2 3)

                    ; this gets translated to (update-fn current-value args)

                    ; if you just want to update state without caring about
                    ; previous value you can just use reset!
                    (reset! counter -1)
                    ```
                </section-->

                <!-- section data-markdown>
                    ```clj
                    ; what happens if two threads call swap! on the same
                    ; atom ? can we lose one of those updates ?
                    ; the answer is no since atoms follow compare and set
                    ; semantics.
                    ; what this means is that atoms
                    ; 1. read current state of the atom
                    ; 2. apply update function
                    ; 3. recheck that atom's current value is same as step 1
                    ; 4. if yes, then update atom to new state
                    ; 5. else go through the process again
                    ```
                </section-->

                <!-- section data-markdown>
                    ```clj
                    ; make the below test cases pass
                    (def counter (atom 0))

                    (= __ @counter)

                    (= __ (do (swap! counter inc)
                    @counter))

                    (= 5 (do __
                    @counter))

                    (= __ (do (swap! counter + 1 2 3 4 5)
                    @counter))
                    ```
                </section-->

                <!-- section data-markdown>
                    ```clj
                    ; refs are another reference type that allow you
                    ; to update the state of multiple entities using
                    ; transaction semantics
                    (def account-a (ref {:name "a" :balance 1000}))
                    (def account-b (ref {:name "b" :balance 200000}))

                    ; we can deref refs to get their value
                    (:balance @account-a)

                    ; now we want to transfer some money from account-b to a
                    ; but we want this done as a transaction just like in databases
                    ```
                </section-->

                <!-- section data-markdown>
                    ```clj
                    ; we use alter to  modify refs within a transaction started
                    ; by dosync
                    ; calling alter without an enclosing transaction causes
                    ; an error

                    (dosync
                    (alter account-a update-in [:balance] + 1000)
                    (alter account-b update-in [:balance] - 1000))

                    ; if we now check the values of the refs we see
                    @account-a
                    ;=> {:name "a", :balance 2000}

                    @account-b
                    ;=> {:name "b", :balance 199000} 
                    ```
                </section-->

                <!-- section data-markdown>
                    ```clj
                    ; transactions on refs support the ACI properties, 
                    ; subset of ACID in databases

                    ; they are atomic i.e. all refs are updated or none
                    ; they are consistent, meaning refs will always have valid states
                    ; they are isolated i.e. transactions act as if executed serially

                    ; if two threads run simultaneous transactions, 
                    ; one of them will retry 
                    ```
                </section-->

                <!-- section data-markdown>
                    ```clj
                    ; finally ref-set can be used to update the value of
                    ; any ref

                    (dosync
                    (ref-set account-a {:name "a" :balance 0}))
                    ```
                </section-->

                <!-- section data-markdown>
                    ```clj
                    ; make the below test cases pass

                    (def the-world (ref "hello"))

                    (= __ (do (dosync (ref-set the-world "better"))
                    @the-world))

                    (= __ (let [exclamator (fn [x] (str x "!"))]
                    (dosync (alter the-world exclamator)
                    (alter the-world exclamator)
                    (alter the-world exclamator))
                    @the-world))

                    (= 0 (do __
                    @the-world))
                    ```
                </section-->

                <!-- section data-markdown>
                    ```clj
                    ; agents are a reference type that have a queue holding
                    ; the actions that need to be performed on the agent's value

                    (def simple-agent (agent []))

                    ; we can enqueue an action for the agent by using send
                    ; or send-off

                    (send simple-agent conj "abcd")

                    @simple-agent
                    ;=> ["abcd"]

                    ; send returns immediately with the value of the agent 
                    ; the update on the agent happens in a thread on thread pool
                    ```
                </section-->

                <!-- section data-markdown>
                    ```clj
                    ; what about send-off ?
                    ; send works with the fixed thread pool and 
                    ; hence if all your threads are busy your agent may freeze

                    ; send-off potentially spawns a new thread and executes the
                    ; function  

                    ; this means that send-off may be a bit slower but you should 
                    ; use it for long running/blocking tasks so as not to block all
                    ; threads of the fixed thread pool
                    ```
                </section-->

                <!-- section data-markdown>
                    ```clj
                    ; there are other ways of getting concurrency or writing
                    ; high volume data processing systems in clojure
                    ; you may want to explore them later

                    ; tranducers
                    ; core.async
                    ```
                </section-->

                <section data-markdown>
                    ```clj
                    ; open the file divisors_test.clj
                    ; and make the test cases pass
                    ```
                </section>

                <section data-markdown>
                    ```clj
                    ; this is my solution
                    (fn [n]
                      (filter #(zero? (rem n %)) 
                        (range 1 n))) 
                    ```
                </section>

                <section data-markdown>
                    ```clj
                    ; write a function that checks if a number is a 
                    ; perfect number or not
                    ; a perfect number is one which is equal to
                    ; the sum of it's divisors

                    (= (__ 6) true)

                    (= (__ 7) false)

                    (= (__ 496) true)

                    (= (__ 500) false)

                    (= (__ 8128) true)
                    ```
                </section>

                <!-- section>
                    <h3>Organizing your project</h3>
                    <p>Leiningen is the most prevalent build tool for clojure</p>
                    <p>Boot is another one gaining in popularity</p>
                    <p>We will focus on leiningen for now</p>
                </section-->

                <!-- section data-markdown>
                    ```clj
                    ; to create a new project we can run the following

                    lein new app my-app

                    ; this will create a directory structure that looks like

                    <pre class="pygments highlight"><code data-lang="clojure" class="block"><span class="tok-err">|</span> <span class="tok-nv">.gitignore</span>
                        <span class="tok-err">|</span> <span class="tok-nv">doc</span>
                        <span class="tok-err">|</span> <span class="tok-err">|</span> <span class="tok-nv">intro.md</span>
                        <span class="tok-err">|</span> <span class="tok-nv">project.clj</span>
                        <span class="tok-err">|</span> <span class="tok-nv">README.md</span>
                        <span class="tok-err">|</span> <span class="tok-nv">resources</span>
                        <span class="tok-err">|</span> <span class="tok-nv">src</span>
                        <span class="tok-err">|</span> <span class="tok-err">|</span> <span class="tok-nv">my_app</span>
                        <span class="tok-err">|</span> <span class="tok-err">|</span> <span class="tok-err">|</span> <span class="tok-nv">core.clj</span>
                        <span class="tok-err">|</span> <span class="tok-nv">test</span>
                        <span class="tok-err">|</span> <span class="tok-err">|</span> <span class="tok-nv">my_app</span>
                        <span class="tok-err">|</span> <span class="tok-err">|</span> <span class="tok-err">|</span> <span class="tok-nv">core_test.clj</span>
                    </code></pre>
                    ```
                </section-->

                <!-- section data-markdown>
                    ```clj
                    ; let's take a look at some of the important pieces there

                    ; note that the hyphens in your project name are changed to 
                    ; underscores in the directory and file names

                    ; project.clj holds the configuration and dependencies

                    ; core.clj is a dummy starting point for your project

                    ```
                </section-->

                <!-- section data-markdown>
                    ```clj
                    ; some useful commands are

                    lein deps

                    lein compile

                    lein run

                    lein repl

                    lein uberjar
                    ```
                </section-->

                <!-- section data-markdown>
                    ```clj
                    ; write a function that returns intersection of two sets
                    ; i.e. items common to both sets

                    (= (__ #{0 1 2 3} #{2 3 4 5}) #{2 3})

                    (= (__ #{0 1 2} #{3 4 5}) #{})

                    (= (__ #{:a :b :c :d} #{:c :e :a :f :d}) #{:a :c :d})

                    ```
                </section>

                <section data-markdown>
                    ```clj
                    ; here's one solution

                    #(set (filter  %1 %2))
                    ```
                </section-->

                <!-- section>
                    <h3>Java interop</h3>
                    <ul>
                        <li>Clojure has seamless access to java libraries since it runs on the JVM</li>
                        <li>This allows clojure to use the extensive Java eco-system of libraries</li>
                    </ul>
                </section-->

                <!-- section data-markdown>
                    ```clj
                    ; we can call methods on an object using the (.methodName object)
                    ; notation

                    ; since clojure strings are implemented as java strings
                    ; it allows us to do this

                    (.toUpperCase "hello world")
                    ;=> "HELLO WORLD"

                    (.indexOf (.toUpperCase "hello world") "W")
                    ;=> 6

                    ; and we can use the threading macro for jave interop
                    ; to apply multiple methods

                    (.. "hello world"
                    toUpperCase 
                    (indexOf "W"))
                    ;=> 6
                    ```
                </section-->

                <!-- section data-markdown>
                    ```clj
                    ; we can call static methods of classes or access static fields 
                    ; as follows

                    (java.lang.Math/abs -3)
                    ;=> 3

                    java.lang.Math/PI
                    ;=> 3.141592653589793
                    ```
                </section-->

                <!-- section data-markdown>
                    ```clj
                    ; we can create new objects in two ways

                    (new String)
                    ;=> ""

                    (String.)
                    ;=> ""

                    (String. "hello world")
                    ;=> "hello world"
                    ```
                </section-->

                

                <section>
                    <h2>Resources</h2>
                    <ul>
                        <li>https://clojuredocs.org/</li>
                        <li>http://www.4clojure.com/</li>
                        <li>http://www.braveclojure.com/clojure-for-the-brave-and-true/</li>
                    </ul>
	              </section>

                <section>
	                  <h3>End Note</h3>
	                  <blockquote>
	                      A language that doesn't affect the way you think about programming, is not worth knowing.<br>—Alan Perlis
	                  </blockquote>
	              </section>

            </div>

        </div>

        <script src="reveal.js/lib/js/head.min.js"></script>
        <script src="reveal.js/js/reveal.js"></script>

        <script>

         // Full list of configuration options available at:
         // https://github.com/hakimel/reveal.js#configuration
         Reveal.initialize({
             controls: true,
             progress: true,
             history: true,
             center: true,

             transition: 'slide', // none/fade/slide/convex/concave/zoom

             math: {
					       mathjax: 'reveal.js/plugin/math/MathJax/MathJax.js',
					       config: 'TeX-AMS_CHTML-full'
				     },
             // Optional reveal.js plugins
             dependencies: [
                 { src: 'reveal.js/lib/js/classList.js', condition: function() { return !document.body.classList; } },
                 { src: 'reveal.js/plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
                 { src: 'reveal.js/plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
                 { src: 'reveal.js/plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
                 { src: 'reveal.js/plugin/zoom-js/zoom.js', async: true },
                 { src: 'reveal.js/plugin/notes/notes.js', async: true },
                 { src: 'reveal.js/plugin/math/math.js', async: true },
                 { src: 'reveal.js/plugin/reveal-sampler-master/sampler.js' }
             ]
         });

        </script>

    </body>

</html>
